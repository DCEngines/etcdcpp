/*

 The MIT License (MIT)

 Copyright (C) 2015 Suryanathan Padmanabhan

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

*/

#ifndef __ETCD_HPP_INCLUDED__
#define __ETCD_HPP_INCLUDED__

#include <curl/curl.h>
#include <iostream>
#include <map>
#include <memory>
#include <sstream>
#include <string>

//#define DEBUG 1
//#define CRAZY_VERBOSE 1
//#define CRAZY_VERBOSE_STREAM stderr

namespace etcd {

//----------------------------- EXCEPTIONS ----------------------------------

/**
 * @brief Exception generated by curl client wrapper
 */
struct ClientException : public std::runtime_error {
    ClientException(const std::string& error)
       :std::runtime_error("etcd unknown exception"),
        error(error)
      {}

    virtual const char* what() const throw() {
        return error.c_str();
    }

    std::string error;
};

/**
 * @brief Exception generated by etcd. The json wrapper throws an exception
 * based on whether etcd returned an error
 */
struct ReplyException : public std::runtime_error {
    ReplyException(int error_code,
                  const std::string& msg,
                  const std::string& cause)
       :std::runtime_error("etcd exception"),
        cause(cause),
        error_code(error_code),
        msg(msg)
      {}

    virtual const char* what() const throw() {
        std::ostringstream estr;
        estr << msg << "["<< error_code << "]: " << cause;
        return estr.str().c_str();
    }

    std::string cause;
    int error_code; 
    std::string msg;
};

// ---------------------------- TYPES ---------------------------------------

namespace internal {
    class Curl;
}

typedef uint16_t Port; 
typedef uint64_t Index;
typedef uint64_t TtlValue;

/**
 * @brief c++ language binding for an etcd curl client
 *
 * @tparam reply is a json wrapper constructable using two constructors,
 * one taking a json reply and another taking a header with a reply which
 * called when you call functions to fetch the curl header
 */

template <typename Reply>
class Client {
  public:
    // LIFECYCLE
    Client(const std::string& server, const Port& port);

    // OPERATIONS

    /**
     * @brief Set a <Key,Value> pair
     *
     * @param key represents the key including the prefix
     * @param value represents the value
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply Set(
        const std::string& key,
        const std::string& value);

    /**
     * @brief Keys in etcd can be set to expire after a specified number of
     * seconds.
     *
     * @param key represents the key includeing the prefix
     * @param value represents the value
     * @param ttl represents the time to live in seconds. If you set ttl to
     * zero, the <Key,Value> pair will expire immediately.
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply Set(
        const std::string& key,
        const std::string& value,
        const TtlValue& ttl);

    /**
     * @brief Clear the ttl on a key. The <Key,Value> pair will not expire.
     *
     * @param key represents the key including the prefix
     * @param value represents the value
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply ClearTtl(
        const std::string& key,
        const std::string& value);

    /**
     * @brief By using POST on a directory, you can create keys with key
     * names that are created in-order
     *
     * @param dir represents the dir for creating in-ordered keys
     * @param value represents the value
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply SetOrdered(
        const std::string& dir,
        const std::string& value);

    /**
     * @brief Return the value corrseponding to a key. Will throw etcd::Exception
     * Key not found exception if a key is not found. 
     *
     * @param key the key to fetch
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply Get(const std::string& key);

    /**
     * @brief Recursively get the complete DOM represented by key
     *
     * @param key the key or directory to fetch
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply GetAll(const std::string& key);

    /**
     * @brief enumerate the in-order keys as a sorted list
     *
     * @param dir the directory which holds the in-order key
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply GetOrdered(const std::string& dir);

    /**
     * @brief Delete a <Key,Value> pair
     *
     * @param key the key or empty directory to delete
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply Delete(const std::string& key);

    /**
     * @brief Add a directory
     *
     * @param dir full prefix of the directory
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply AddDirectory(const std::string& dir);

    /**
     * @brief Add a direcotry that expires after ttl seconds
     *
     * @param dir full prefix name of directory to add
     * @param ttl expiry in seconds
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply AddDirectory(const std::string& dir, const TtlValue& ttl);

    /*
     * Update a directory ttl
     */
    /**
     * @brief Update the ttl of a directory. The directory can only be
     * updated with a specific ttl. Use clear_ttl to clear the ttl. A ttl
     * value of zero will expire the directory immediately
     *
     * @param dir full prefix name of the directory to delete
     * @param ttl expiry in seconds
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply UpdateDirectoryTtl(const std::string& dir, const TtlValue& ttl);

    /**
     * @brief Delete a directory and optionally its contents. If recursive is
     * false and the directory is not empty, it will throw an exception
     *
     * @param dir full prefix name of the directory
     * @param recursive flag to indicate whether we should delete child nodes.
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply DeleteDirectory(const std::string& dir, bool recursive = false);

    /**
     * @brief Atomic compare and swap if the previous value of key matches
     * a specified key
     *
     * @param key full prefix of the key to update
     * @param value new value of the key
     * @param prevValue existing value to check
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply CompareAndSwapIf(
        const std::string& key,
        const std::string& value,
        const std::string& prevValue);

    /**
     * @brief Atomically compare and swap a key if the specified previousIndex
     * matches the current modified index of the key
     *
     * @param key full prefix of the key to update
     * @param value new value of the key
     * @param prevIndex index to match with the modifiedIndex
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply CompareAndSwapIf(
        const std::string& key,
        const std::string& value,
        const Index& prevIndex);

    /**
     * @brief Atomically compare and swap a key based on whether it alreayd
     * exists or not
     *
     * @param key full prefix of the key to update
     * @param value new value
     * @param prevExist should the key already exist or not?
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply CompareAndSwapIf(
        const std::string& key,
        const std::string& value,
        bool prevExist);

    /**
     * @brief Atomically compare and delete a key
     *
     * @param key full prefix of the key to delete
     * @param prevValue only delete the key if the value matches this field
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply CompareAndDeleteIf(
        const std::string& key,
        const std::string& prevValue);

    /**
     * @brief Atomically compare and delete a key if the current modified
     * index is equal to the passed index
     *
     * @param key full prefix of the key to delete
     * @param prevIndex only delete if the modifiedIndex is equal to this field
     *
     * @return returns <template Reply> constructed with a json std::string
     */
    Reply CompareAndDeleteIf(
        const std::string& key,
        const Index& prevIndex);

  private:
    // CONSTANTS
    const char *kPutRequest = "PUT";
    const char *kPostRequest = "POST";
    const char *kDeleteRequest = "DELETE";

    const char *kValue = "value";
    const char *kTttl = "ttl";
    const char *kDir = "dir";
    const char *kPrevExist = "prevExist";
    const char *kPrevIndex = "prevIndex";
    const char *kPrevValue = "prevValue";
    const char *kSortedSuffix = "?recursive=true&sorted=true";

    // DATA
    bool enable_header_;
    std::string url_;
    std::string url_prefix_;
    std::unique_ptr<internal::Curl> handle_;

    // OPERATIONS
    Reply _GetReply(const std::string& json);
};

/**
 * @brief A watch abstraction for monitoring a key or directory
 *
 * @tparam Reply json reply wrapper
 */
template <typename Reply>
class Watch {
  public:
    // TYPES
    typedef std::function <void (const Reply& r)> Callback;
   
    // LIFECYCLE
    Watch(const std::string& server, const Port& port);

    void Run(const std::string& key, Callback callback);

  private:
    // DATA MEMBERS
    Index prev_index_;
    std::string url_prefix_;
    std::unique_ptr<internal::Curl> handle_;
};

//------------------------------ INTERNAL TYPES -----------------------------

namespace internal {

struct CurlUnknownException : public std::runtime_error {
    CurlUnknownException(const std::string& error)
       :std::runtime_error("curl unknown exception"),
        error(error)
      {}

    virtual const char* what() const throw() {
        return error.c_str();
    }

    std::string error;
};

struct CurlException : public std::runtime_error {
    CurlException(CURLcode errorCode,
                  const std::string& msg)
       :std::runtime_error("curl exception"),
        error_code(errorCode),
        msg(msg)
      {}

    virtual const char* what() const throw() {
        std::ostringstream estr;
        estr << msg << " [code: " << error_code << "] ";
        estr << curl_easy_strerror(error_code);
        return estr.str().c_str();
    }

    CURLcode error_code; 
    std::string msg;
};

typedef std::map<std::string, std::string> CurlOptions;

class Curl {
  public:
    // LIFECYCLE
    Curl();
    ~Curl();

    // OPERATIONS
    std::string Get(const std::string& url);

    std::string Set(const std::string& url,
             const std::string& type,
             const CurlOptions& options);

    void EnableHeader(bool onOff);

    std::string GetHeader();

    // callback from 'C' functions
    size_t WriteCb(void* buffer_p, size_t size, size_t nmemb) throw();
    size_t HeaderCb(void* buffer_p, size_t size, size_t nmemb) throw();

  private:
    // DATA MEMBERS
    CURL *handle_;
    std::ostringstream write_stream_;
    std::ostringstream header_stream_;
    bool enable_header_;

    // LIFECYCLE
    Curl(const Curl& rhs);
    void operator=(const Curl&& rhs);

    // OPERATIONS
    void _CheckError(CURLcode err, const std::string& msg);
    void _ResetHandle();

    void _SetCommonOptions(const std::string& url);

    void _SetGetOptions(const std::string& url);

    void _SetPostOptions(const std::string& url,
                         const std::string& type,
                         const CurlOptions& options);
};
}

//------------------------------- LIFECYCLE ----------------------------------

template <typename Reply> Client<Reply>::
Client(const std::string& server, const Port& port)
try:
    handle_(new internal::Curl()) {
    std::ostringstream ostr;
    ostr << "http://" << server << ":" << port; 
    url_ = ostr.str();
    ostr << "/v2/keys";
    url_prefix_ = ostr.str();
} catch (const std::exception& e) {
    throw ClientException(e.what());
}

//------------------------------- OPERATIONS ---------------------------------
template <typename Reply> Reply Client<Reply>::
Set(const std::string& key, const std::string& value) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + key, kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
Set(const std::string& key,
    const std::string& value,
    const TtlValue& ttl) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + key, kPutRequest,
            {
                {kValue, value},
                {kTttl, std::to_string(ttl)},
            });
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
ClearTtl(const std::string& key, const std::string& value) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + key, kPutRequest,
            {{kValue, value}, {kTttl, ""}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}


template <typename Reply> Reply Client<Reply>::
SetOrdered(const std::string& dir, const std::string& value) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir,
                kPostRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
Get(const std::string& key) {
    std::string ret;
    try {
        ret = handle_->Get(url_prefix_ + key);
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
GetAll(const std::string& key) {
    std::string ret;
    try {
        ret = handle_->Get(url_prefix_ + key + "/recursive=true");;
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
GetOrdered(const std::string& dir) {
    std::string ret;
    try {
        ret = handle_->Get(url_prefix_ + dir + std::string(kSortedSuffix));
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
Delete(const std::string& key) {
    std::string ret;
    try {
        ret = handle_->Set(
            url_prefix_ + key, kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
AddDirectory(const std::string& dir) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir, kPutRequest, {{kDir, "true"}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
AddDirectory(const std::string& dir, const TtlValue& ttl) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir, kPutRequest,
            {
                {kDir, "true"},
                {kTttl, std::to_string(ttl)},
            });
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
UpdateDirectoryTtl(const std::string& dir, const TtlValue& ttl) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir, kPutRequest,
            {
                {kDir, "true"},
                {kTttl, std::to_string(ttl)},
                {kPrevExist, "true"}
            });
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
DeleteDirectory(const std::string& dir, bool recursive) {
    std::ostringstream ostr;
    ostr << url_prefix_ + dir << "?dir=true";
    if (recursive)
        ostr << "&recursive=true";

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndSwapIf(
    const std::string& key,
    const std::string& value,
    const std::string& prevValue) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevValue << "=" << prevValue;

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndSwapIf(
     const std::string& key,
     const std::string& value,
     const Index& prevIndex) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevIndex
         << "=" << std::to_string(prevIndex);

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndSwapIf(
     const std::string& key,
     const std::string& value,
     bool prevExist) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevExist
         << "=" << (prevExist ? "true" : "false"); 

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndDeleteIf(const std::string& key, const std::string& prevValue) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevValue << "=" << prevValue;

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndDeleteIf(const std::string& key, const Index& prevIndex) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevIndex
         << "=" << std::to_string(prevIndex);

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

//------------------------------ OPERATIONS ----------------------------------

template <typename Reply> Reply Client<Reply>::
_GetReply(const std::string& json) {
    if (enable_header_)
        return Reply (handle_->GetHeader(), json);
    return Reply(json);
}

//------------------------------- LIFECYCLE ----------------------------------

template <typename Reply> Watch<Reply>::
Watch(const std::string& server, const Port& port)
try:
    handle_(new internal::Curl()),
    prev_index_(0) {
    std::ostringstream ostr;
    ostr << "http://" << server << ":" << port << "/v2/keys";
    url_prefix_ = ostr.str();
} catch (const std::exception& e) {
    throw ClientException(e.what());
}

//------------------------------- OPERATIONS ---------------------------------

template <typename Reply> void Watch<Reply>::
Run(const std::string& key, Watch::Callback callback) {
    const std::string watch_url_base = url_prefix_ + key + "?wait=true";
    const std::string wait_url_base = watch_url_base + "&waitIndex=";

    std::string watch_url = watch_url_base;

    int max_failures = 5;

    while (max_failures) {
        try {
            std::string ret = handle_->Get(watch_url);
            Reply r(ret);
            callback(r);
            prev_index_ = r.get_modified_index();
            watch_url = wait_url_base + std::to_string(prev_index_ + 1);
        } catch (const ReplyException& e) {
            if (e.error_code == 401) {
                // We got an index out of date.
                try {
                // Enable curl headers
                handle_->EnableHeader(true);

                // Get the current state and call back
                std::string ret = handle_->Get(url_prefix_ + key);
                Reply r(ret);
                callback(r);

                // Get the new index from the curl header
                std::istringstream stream(handle_->GetHeader());
                std::string etcd_index_label("X-Etcd-Index: ");
                std::string::size_type len = etcd_index_label.length();
                std::string line;
                std::string::size_type pos;
                while (std::getline(stream, line)) {
                    if ((pos = line.find(etcd_index_label) != std::string::npos))
                    {
                        prev_index_ = std::stoi(line.substr(pos+len-1));
                        break;
                    }
                }
                handle_->EnableHeader(false);
                watch_url = wait_url_base + std::to_string(prev_index_ + 1);
                } catch (...) {}
            }
            max_failures--;
        } catch (const std::exception& e) {
            // Possibly timed out and we didn't get a previous index
            max_failures--;
            // ToDo check timout options with curl
        }
    }
    return;
}

//--------------------------- INTERNAL IMPL ---------------------------------

namespace internal {

extern "C" size_t
_WriteCb(void* buffer_p, size_t size, size_t nmemb, internal::Curl* curl_p) {
    return curl_p->WriteCb(buffer_p, size, nmemb);
}

extern "C" size_t
_HeaderCb(void* buffer_p, size_t size, size_t nmemb, internal::Curl* curl_p) {
    return curl_p->HeaderCb(buffer_p, size, nmemb);
}

#ifdef DEBUG
extern "C" int
_CurlTrace(CURL *handle, curl_infotype type,
           char *data, size_t size,
           void *userp);
#endif

//------------------------------- LIFECYCLE ----------------------------------

Curl::
Curl()
  :handle_(NULL),
   enable_header_(false) {

    curl_global_init(CURL_GLOBAL_ALL);
    handle_ = curl_easy_init();
    if (! handle_) 
        throw CurlUnknownException("failed init");
}

Curl::
~Curl() {
    curl_easy_cleanup(handle_);
}

//------------------------------- OPERATIONS ---------------------------------

std::string Curl::
Get(const std::string& url) {
    _ResetHandle();
    _SetGetOptions(url);

    CURLcode err = curl_easy_perform(handle_);
    _CheckError(err, "easy perform");

    return write_stream_.str();
}

std::string Curl::
Set(const std::string& url,
    const std::string& type,
    const CurlOptions& options) {

    _ResetHandle();
    _SetPostOptions(url, type, options);

    CURLcode err = curl_easy_perform(handle_);
    _CheckError(err, "easy perform");

    return write_stream_.str();
}

void Curl::
EnableHeader(bool onOff) {
    enable_header_ = onOff;
}

std::string Curl::
GetHeader() {
    return header_stream_.str();
}

size_t Curl::
WriteCb(void* buffer_p, size_t size, size_t nmemb) throw() {
    write_stream_ << std::string ((char*) buffer_p, size * nmemb);
    if (write_stream_.fail())
        return 0;
    return size * nmemb;
}

size_t Curl::
HeaderCb(void* buffer_p, size_t size, size_t nmemb) throw() {
    header_stream_ << std::string ((char*) buffer_p, size * nmemb);
    if (header_stream_.fail())
        return 0;
    return size * nmemb;
}

inline void Curl::
_CheckError(CURLcode err, const std::string& msg) {
    if (err != CURLE_OK) {
        throw CurlException(err, std::string("Failed ") + msg);
    }
}

void Curl::
_ResetHandle() {
    curl_easy_reset(handle_);
#ifdef  DEBUG
    curl_easy_setopt(handle_, CURLOPT_VERBOSE, 1L);
#ifdef  CRAZY_VERBOSE
    curl_easy_setopt(handle_, CURLOPT_DEBUGFUNCTION, _CurlTrace);
#endif
#endif
}

void Curl::
_SetCommonOptions(const std::string& url) {

    // set url
    CURLcode err = curl_easy_setopt(handle_, CURLOPT_URL, url.c_str());
    _CheckError(err, "set url");

    // Allow redirection
    err = curl_easy_setopt(handle_, CURLOPT_FOLLOWLOCATION, 1L);
    _CheckError(err, "set follow location");

    // Clear write stream
    write_stream_.str("");
    write_stream_.clear();

    // Set callback for write
    err = curl_easy_setopt(handle_, CURLOPT_WRITEFUNCTION, _WriteCb);
    _CheckError(err, "set write callback");

    // Set callback data
    err = curl_easy_setopt(handle_, CURLOPT_WRITEDATA, this);
    _CheckError(err, "set write data");

    if (enable_header_) {
        // Get curl header
        
        // clear existing header data
        header_stream_.str("");
        header_stream_.clear();

        // Set header callback function
        err = curl_easy_setopt(handle_, CURLOPT_HEADERFUNCTION, _HeaderCb);
        _CheckError(err, "set header callback");

        // Set header user data for callback function
        err = curl_easy_setopt(handle_, CURLOPT_HEADERDATA, this);
        _CheckError(err, "set header data");
    }
 
    // Set the user agent. Some servers requires this on requests
    err = curl_easy_setopt(handle_, CURLOPT_USERAGENT, "libcurl-agent/1.0");
    _CheckError(err, "set write data");
}

void Curl::
_SetGetOptions(const std::string& url) {
    _SetCommonOptions(url);
}

void Curl::
_SetPostOptions(
    const std::string& url,
    const std::string& type,
    const CurlOptions& options) {

    CURLcode err;
    err = curl_easy_setopt(handle_, CURLOPT_CUSTOMREQUEST, type.c_str());
    _CheckError(err, "set request type");

    _SetCommonOptions(url);

    err = curl_easy_setopt(handle_, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL);
    _CheckError(err, "set post redir");

    std::ostringstream ostr;
    for (auto const& opt :options) {
        ostr << opt.first << '=' << opt.second << ';';
    }

    std::string opts (ostr.str());
    if (! opts.empty()) {
        err = curl_easy_setopt(handle_, CURLOPT_POST, 1L);
        _CheckError(err, "set post");
        err = curl_easy_setopt(handle_, CURLOPT_COPYPOSTFIELDS, opts.c_str());
        _CheckError(err, "set copy post fields");
    }
}

#ifdef CRAZY_VERBOSE
static
void dump(const char *text,
          FILE *stream, unsigned char *ptr, size_t size) {
  size_t i;
  size_t c;
  unsigned int width=0x10;
 
  fprintf(stream, "%s, %10.10ld bytes (0x%8.8lx)\n",
          text, (long)size, (long)size);
 
  for(i=0; i<size; i+= width) {
    fprintf(stream, "%4.4lx: ", (long)i);
 
    /* show hex to the left */
    for(c = 0; c < width; c++) {
      if(i+c < size)
        fprintf(stream, "%02x ", ptr[i+c]);
      else
        fputs("   ", stream);
    }
 
    /* show data on the right */
    for(c = 0; (c < width) && (i+c < size); c++)
      fputc((ptr[i+c]>=0x20) && (ptr[i+c]<0x80)?ptr[i+c]:'.', stream);
 
    fputc('\n', stream); /* newline */
  }
}
 
static
int _CurlTrace(CURL *handle, curl_infotype type,
             char *data, size_t size,
             void *userp) {
  const char *text;
  (void)handle; /* prevent compiler warning */
 
  switch (type) {
  case CURLINFO_TEXT:
    fprintf(stderr, "== Info: %s", data);
  default: /* in case a new one is introduced to shock us */
    return 0;
 
  case CURLINFO_HEADER_OUT:
    text = "=> Send header";
    break;
  case CURLINFO_DATA_OUT:
    text = "=> Send data";
    break;
  case CURLINFO_SSL_DATA_OUT:
    text = "=> Send SSL data";
    break;
  case CURLINFO_HEADER_IN:
    text = "<= Recv header";
    break;
  case CURLINFO_DATA_IN:
    text = "<= Recv data";
    break;
  case CURLINFO_SSL_DATA_IN:
    text = "<= Recv SSL data";
    break;
  }
 
  dump(text, CRAZY_VERBOSE_STREAM, (unsigned char *)data, size);
  return 0;
}
#endif // CRAZY_VERBOSE

} // namespace internal
} // namespace etcd

#endif // __ETCD_HPP_INCLUDED__

